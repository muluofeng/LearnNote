

### 什么是 IO 

我们都知道unix世界里、一切皆文件、而文件是什么呢？文件就是一串二进制流而已、不管socket、还是FIFO、管道、终端、对我们来说、一切都是文件、一切都是流、在信息交换的过程中、我们都是对这些流进行数据的收发操作、简称为I/O操作(input and output)、往流中读出数据、系统调用read、写入数据、系统调用write
###  IO 交互



![1639808731294.png](https://qiniu.muluofeng.com/1639808731294.png)


用户空间 <—–> 内核空间
内核空间 <—–> 设备空间

内核空间中存放的是内核代码和数据，操作系统和驱动程序运行在内核空间
而进程的用户空间中存放的是用户程序的代码和数据

不管是内核空间还是用户空间、它们都处于虚拟空间中、Linux使用两级保护机制：0级供内核使用、3级供用户程序使用，内核空间和用户空间不能简单的使用指针传递数据 ,内核会为每个I/O设备维护一个缓冲区，用户空间的数据可以被换出

所以、对于一个网络输入操作通常包括两个不同阶段：
- 1. 等待网络数据到达网卡 –> 读取到内核缓冲区
- 2. 从内核缓冲区复制数据 –> 用户空间    （copy数据）

所以网络环境下，将I/O分为两步 **等待**   **数据copy**

应用的读IO操作

- 应用进行发起read系统调用。 
- 内核接受应用的请求，如果内核buf有数据，则把数据copy到应用buf中，调用结束。
-  如果内核buf中没有数据，会向io模块发送请求，io模块和硬件交互。 
- 4.当网卡接收到协议栈的数据后， 网卡 会通过DMA 技术将数据copy到内核 buf 中 内核将内核buf的数据copy到应用的buf中，调用结束

### IO模型
分类
- 阻塞IO模型
- 非阻塞IO模型
- IO复用模型
- 信号驱动的IO模型
- 异步IO模型


#### 1. 阻塞IO


![1639809730481.png](https://qiniu.muluofeng.com/1639809730481.png)

当用户进程调用了recvfrom这个系统调用、内核就开始了IO的第一个阶段：准备数据、对于网络IO来说、很多时候数据在一开始还没有到达（比如、还没有收到一个完整的UDP包）、这个时候内核就要等待足够的数据到来、而在用户进程这边、整个进程会被阻塞、当内核一直等到数据准备好了、它就会将数据从内核中拷贝到用户内存、然后返回结果、用户进程才解除阻塞的状态、重新运行起来、几乎所有的程序员第一次接触到的网络编程都是从listen()、send()、recv()等接口开始的、这些接口都是阻塞型的、

**blocking IO的特点就是在IO执行的两个阶段（等待数据和拷贝数据两个阶段）都被阻塞了**

优缺点
- 进程阻塞挂起不消耗CPU资源、及时响应每个操作
- 实现难度低、开发应用较容易
- 适用并发量小的网络应用开发
- 不适用并发量大的应用、因为一个请求IO会阻塞进程、所以、得为每请求分配一个处理进程（线程）以及时响应、系统开销大

典型应用： 阻塞Socket、Java BIO
####  2. 非阻塞IO模型



![1639810249091.png](https://qiniu.muluofeng.com/1639810249091.png)


当用户进程发出read操作时、如果内核中的数据还没有准备好、那么它并不会block用户进程、而是立刻返回一个error、从用户进程角度讲、它发起一个read操作后、并不需要等待、而是马上就得到了一个结果、用户进程判断结果是一个error时、它就知道数据还没有准备好、于是它可以再次发送read操作、一旦内核中的数据准备好了、并且又再次收到了用户进程的系统调用、那么它马上就将数据拷贝到了用户内存、然后返回、非阻塞的接口相比于阻塞型接口的显著差异在于、在被调用之后立即返回、

优缺点

- 进程轮询（重复）调用、消耗CPU的资源
- 实现难度低、开发应用相对阻塞IO模式较难
- 适用并发量较小、且不需要及时响应的网络应用开发


典型应用： ocket 设置 NONBLOCK

####  3.  IO复用模型


![1639811537399.png](https://qiniu.muluofeng.com/1639811537399.png)

多个的进程的IO可以注册到一个复用器（select）上、当用户进程调用该select、select会监听所有注册进来的IO、如果select所有监听的IO在内核缓冲区都没有可读数据、select调用进程会被阻塞、而当任一IO在内核缓冲区中有可数据时、select调用就会返回、而后select调用进程可以自己或通知另外的进程（注册进程）来再次发起读取IO、读取内核中准备好的数据、多个进程注册IO后、只有一个select调用进程被阻塞

IO复用相对阻塞和非阻塞更难简单说明、所以额外解释一段、其实IO复用模型和阻塞IO模型并没有太大的不同、事实上、还更差一些、因为这里需要使用两个系统调用（select和 recvfrom）、而阻塞IO模型只有一次系统调用(recvfrom)、但是、用select的优势在于它可以同时处理多个连接、所以如果处理的连接数不是很高的话、使用select/epoll的web server不一定比使用多线程加阻塞IO的web server性能更好、可能延迟还更大、select/epoll的优势并不是对于单个连接能处理得更快、而是在于能处理更多的连接

**在IO复用模型中、对于每一个socket、一般都设置成为非阻塞、但是、如上图所示、整个用户的进程其实是一直被阻塞的、只不过进程是被select这个函数阻塞、而不是被socket IO给阻塞**

典型应用：Java NIO、Nginx（epoll、poll、select）

优缺点

- 专一进程解决多个进程IO的阻塞问题、性能好、Reactor模式
- 实现、开发应用难度较大
- 适用高并发服务应用开发、一个进程/线程响应多个请求


#### 4. 信号驱动式IO模型

![1639813845830.png](https://qiniu.muluofeng.com/1639813845830.png)



信号驱动式IO就是指进程预先告知内核、向内核注册一个信号处理函数、然后用户进程返回不阻塞、当内核数据就绪时会发送一个信号给进程、用户进程便在信号处理函数中调用IO读取数据、从图中明白实际IO内核拷贝到用户进程的过程还是阻塞的、信号驱动式IO并没有实现真正的异步、因为通知到进程之后、依然是由进程来完成IO操作


#### 5. 异步IO模型


![1639813971588.png](https://qiniu.muluofeng.com/1639813971588.png)


用户进程发起aio_read（POSIX异步IO函数aio_或者lio_开头）操作之后、给内核传递描述符、缓冲区指针、缓冲区大小和read相同的三个参数以及文件偏移（与lseek类似）、告诉内核当整个操作完成时、如何通知我们、立刻就可以开始去做其它的事、而另一方面、从内核的角度、当它受到一个aio_read之后、首先它会立刻返回、所以不会对用户进程产生任何阻塞、然后、内核会等待数据准备完成、然后将数据拷贝到用户内存、当这一切都完成之后、内核会给用户进程发送一个信号、告诉它aio_read操作完成了

异步IO的工作机制是：告知内核启动某个操作、并让内核在整个操作完成后通知我们、这种模型与信号驱动的IO区别在于、信号驱动IO是由内核通知我们何时可以启动一个IO操作、这个IO操作由用户自定义的信号函数来实现、而异步IO模型是由内核告知我们IO操作何时完成、

在异步IO模型中、真正实现了POSIX描述的异步IO、是五种IO模型中唯一的异步模型

典型应用：Java 7 AIO、高性能服务器应用

- 不阻塞、数据一步到位、Proactor模式
- 需要操作系统的底层支持、LINUX 2.5 版本内核首现、2.6 版本产品的内核标准特性
- 回调机制、实现、开发应用难度大
- 非常适合高性能高并发应用


#### 五种IO模型的比较


![1639814408815.png](https://qiniu.muluofeng.com/1639814408815.png)


### 同步和异步的区别、阻塞和非阻塞的区别

**同步和异步的区别 主要看请求发起方的对消息的结果是主动发起的还是被动通知的**

**阻塞和非阻塞的区别 主要看客户端发出请求之后，在服务端处理请求的过程中，客户端是直接挂起等待结果还是继续做其他任务**