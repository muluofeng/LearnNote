
### 1.7 和 1.8 区别
### 扩容机制
### 线程不安全的原因
### 为什么大小为2的幂次
主要是为了位运算，位运算的效率高，之所以选择16，是为了服务将Key映射到index的算法
```java
static int indexFor(int h, int length) {
        return h & (length-1);
}
```
15的的二进制是1111，那10111011000010110100 &1111 十进制就是4
之所以**用位与运算效果与取模一样**，性能也提高了不少！

### 那为啥用16不用别的呢？
因为在使用是2的幂的数字的时候，Length-1的值是所有二进制位全为1，这种情况下，index的结果等同于HashCode后几位的值。

只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的。

这是为了实现均匀分布。


16 我觉得就是一个经验值，定义16没有很特别的原因，只要是2次幂，其实用 8 和 32 都差不多。用16只是因为作者认为16这个初始容量是能符合常用而已。



### 为什么1.7采用头插 1.8 采用尾插

使用头插会改变链表的上的顺序，但是如果使用尾插，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了,就是说原本是A->B，在扩容后那个链表还是A->B
![扩容](./images/3481626745051_.pic_hd.jpg)

***Java7在多线程操作HashMap时可能引起死循环，原因是扩容转移后前后链表顺序倒置，在转移过程中修改了原来链表中节点的引用关系。***

***Java8在同样的前提下并不会引起死循环，原因是扩容转移后前后链表顺序不变，保持之前节点的引用关系***


### 为啥我们重写equals方法的时候需要重写hashCode方法呢
重写equals方法我们是继承了object的equals方法，那里的 equals是比较两个对象的内存地址，显然我们new了2个对象内存地址肯定不一样

- 对于值对象，==比较的是两个对象的值
- 对于引用对象，比较的是两个对象的地址

我们去get的时候，他就是根据key去hash然后计算出index，找到了2，那我怎么找到具体的”帅丙“还是”丙帅“呢？

equals！是的，所以如果我们对equals方法进行了重写，建议一定要对hashCode方法重写，***以保证相同的对象返回相同的hash值，不同的对象返回不同的hash值。***

不然一个链表的对象，你哪里知道你要找的是哪个，到时候发现hashCode都一样，这不是完犊子嘛

那什么情况下我要重写呢
例如用到map的时候，map是根据key的hashCode和key.equals是否都相等判断是否存在重复的entry的。所以如果我们从map中put进两个值(key都为new User(1))，此时我们只重写了equals，而没有重写hashCode，得到的结果(size = 2)和我们期望的结果(size = 1)将不一样